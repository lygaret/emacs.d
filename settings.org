* Configuration
:PROPERTIES:
:header-args: :results silent
:startup:  indent
:END:

** custom key binds

| family     | bind        | description                                                 |
|------------+-------------+-------------------------------------------------------------|
| org        | C-c oa      | org agenda                                                  |
| org        | C-c oc      | org capture                                                 |
| org        | C-c ol      | org store-link                                              |
| magit      | C-c gs      | git status                                                  |
| projectile | C-c pp      | projectile-switch-project, list/search projects             |
| projectile | C-c ph      | projectile-helm, list/search buffers and files (in-project) |
| buffers    | C-c b       | buffer list/search (all-buffers)                            |
| window     | C-w h/j/k/l | move to window left/below/above/right                       |
| window     | C-w H/J/K/L | split window and move left/below/above/right                |
|            |             |                                                             |

> thanks to Lee for the idea to capture these all in one place

** variables

#+BEGIN_SRC emacs-lisp :results output silent
  (defvar my/vis-theme-package 'material-theme)
  (defvar my/vis-theme-name    'material)
  (defvar my/vis-default-font  "Fira Mono 8")

  (defvar my/org-inbox-file "~/sync.dropbox/Org/inbox.org")
  (defvar my/org-journal-file "~/sync.dropbox/Org/journal.org")

  (defmacro xx (&rest body) nil)
#+END_SRC

** ~use-package~

- ~:init~ runs before the package is loaded, and can be used to force eager loading
- ~:config~ runs after load, meaning it's deferred along with the package.

#+BEGIN_SRC emacs-lisp
  (unless (package-installed-p 'use-package)
    (package-install 'use-package))
  (setq use-package-verbose t)
  (require 'use-package)
#+END_SRC

** ui / ux

*** visual theme

Let's get pretty.

#+BEGIN_SRC emacs-lisp
  ;; ensure the theme package is installed
  (unless (package-installed-p my/vis-theme-package)
    (package-install my/vis-theme-package))

  ;; require it and set the theme
  (require my/vis-theme-package)
  (load-theme my/vis-theme-name t)

  ;; set the default font
  ;; t t = <dont resize window> <for all/future frames in the session>
  (set-frame-font my/vis-default-font t t)

  ;; hide menus and such
  (when window-system
    (tooltip-mode -1)
    (tool-bar-mode -1)
    (menu-bar-mode -1)
    (scroll-bar-mode -1))

  ;; display whitespace
  (setq whitespace-style '(face trailing tabs spaces newline empty indentation space-mark tab-mark newline-mark))
  (setq whitespace-display-mappings
    '((space-mark 32 [183] [46])
      (newline-mark 10 [8629 10] [182 10])
      (tab-mark 9 [9655 9] [92 9])))
#+END_SRC

*** TODO modeline/diminish

Things I know I want:

- current file name (with the whole <project> thing)
- current project name
- file location (col/row)
- evil mode
- git info
- don't really care about most minor modes

*** TODO window/buffer navigation

#+BEGIN_SRC emacs-lisp
  ;; buffers are sorted in recent order, so C-c b <Enter> will switch between buffers
  (global-set-key (kbd "C-c b") 'helm-buffers-list)

  ;; window manipulation, C-c w(hjkl/HJKL) to move, create splits
  (global-set-key (kbd "C-c wh") 'evil-window-left)
  (global-set-key (kbd "C-c wl") 'evil-window-right)
  (global-set-key (kbd "C-c wj") 'evil-window-down)
  (global-set-key (kbd "C-c wk") 'evil-window-up)

  (global-set-key (kbd "C-c w S-h") 'split-window-horizontally)
  (global-set-key (kbd "C-c w S-l") (lambda () (interactive) (split-window-horizontally) (other-window 1)))
  (global-set-key (kbd "C-c w S-j") (lambda () (interactive) (split-window-vertically) (other-window 1)))
  (global-set-key (kbd "C-c w S-k") 'split-window-vertically)

  ;; back and forth forever
  (global-set-key (kbd "C-c ww") 'other-window)
#+END_SRC

*** evil mode

#+BEGIN_SRC emacs-lisp
  (use-package evil
    :ensure t
    :init (evil-mode 1)
    :config (progn

(defun forward-highlight-chars ()
  (interactive)
  (save-excursion
    (let (charset '())
      (progn
        (forward-char)
        (while (let* ((current-character (char-after))
                     (current-point (point)))
                 (unless (memq current-character charset)
                   (progn
                     (add-to-list 'charset current-character)
                     (overlay-put (make-overlay current-point (+ 1 current-point)) 'face 'bold)))
                 (forward-char)
                 (not (eolp))))))))

(defun backward-highlight-chars ()
  (interactive)
  (save-excursion
    (let (charset '())
      (progn
        (backward-char)
        (while (let ((current-character (char-before))
                     (current-point (point)))
                 (unless (memq current-character charset)
                   (progn
                     (add-to-list 'charset current-character)
                     (overlay-put (make-overlay (- current-point 1) current-point) 'face 'bold)))
                 (backward-char)
                 (not (bolp))))))))

(defun my-evil-find-char ()
  (interactive)
  (forward-highlight-chars)
  (call-interactively 'evil-find-char)
  (remove-overlays))

(defun my-evil-find-char-backward ()
  (interactive)
  (backward-highlight-chars)
  (add-hook 'evil-motion-state-exit-hook 'remove-overlays)
  (call-interactively 'evil-find-char-backward))

(define-key evil-motion-state-map "f" 'my-evil-find-char)
(define-key evil-motion-state-map "F" 'my-evil-find-char-backward)
))

  (use-package evil-surround
    :ensure t
    :init (evil-surround-mode )
    :config (xx progn))

  (use-package evil-args
    :ensure t
    :config
    (progn
      (define-key evil-inner-text-objects-map "a" 'evil-inner-arg)
      (define-key evil-outer-text-objects-map "a" 'evil-outer-arg)))
#+END_SRC

**** TODO evil-commentary
**** TODO argument motion

*** affordances

- answer ~y~ when emacs wants you to say ~yes~. that this isn't the default, I'm incredulous about.
- ~visual-line-mode~ turns on word wrap and make line-oriented commands e.g. ~C-a~ work on visual lines rather than physical ones. turn it on everywhere.
- ~hl-line-mode~ highlights the current line

#+BEGIN_SRC emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
(global-visual-line-mode)
(global-hl-line-mode)
#+END_SRC

- ~guide-key~ provides a popup with key bindings for prefix keys if you wait a moment. most of emacs bindings make no sense to me, so having a way to see what bindings exist for a prefix you've already typed is super handy.

#+BEGIN_SRC emacs-lisp
(use-package guide-key
  :ensure t
  :init
    (guide-key-mode 1)
  :config
    (progn
      (setq guide-key/guide-key-sequence t)))
#+END_SRC


** misc

#+BEGIN_SRC emacs-lisp :results output silent
;; Hide backup files in ~./emacs.d/backups~, because the random tilde files are awful.
(setq backup-directory-alist '(("." . "~/.emacs.d/backups")))

;; auto revert files that change on disk and aren't modified
(global-auto-revert-mode 1)
#+END_SRC

** modes
*** prog-mode 

customization here affects most programming modes, so things that I want across the board should go here

- rainbow delimeters makes parens, blocks etc. colored

#+BEGIN_SRC emacs-lisp

  (use-package rainbow-delimiters
    :ensure t
    :init (add-hook 'prog-mode-hook 'rainbow-delimiters-mode))

#+END_SRC

automatically infer tab/space indentation

#+BEGIN_SRC emacs-lisp

(defun how-many-region (begin end regexp &optional interactive)
  "Print number of non-trivial matches for REGEXP in region.
   Non-interactive arguments are Begin End Regexp"

  (interactive "r\nsHow many matches for (regexp): \np")
  (let ((count 0) opoint)
    (save-excursion
      (setq end (or end (point-max)))
      (goto-char (or begin (point)))
      (while (and (< (setq opoint (point)) end)
		  (re-search-forward regexp end t))
	(if (= opoint (point))
	    (forward-char 1)
	  (setq count (1+ count))))
      (if interactive (message "%d occurrences" count))
      count)))

(defun infer-indentation-style ()
  "If the source file uses tabs, we use tabs; spaces, spaces.
   If neither, fallback to our current indent-tabs-mode"
  (interactive)
  (let ((space-count (how-many-region (point-min) (point-max) "^  "))
	      (tab-count (how-many-region (point-min) (point-max) "^\t")))
    (if (> space-count tab-count) (setq ident-tabs-mode nil))
    (if (< space-count tab-count) (setq ident-tabs-mode t))))

(defun set-tab-stop-width (width) 
  "Set all tab stops to WIDTH in current buffer; this updates `tab-stop-width`, but not `tab-width`."
  (interactive "nTab width: ")
  (let* ((max-col (car (last tab-stop-list)))
         (n-tab-stops (/ max-col width)))
    (set (make-local-variable 'tab-stop-list)
         (mapcar (lambda (x) (* width x))
                 (number-sequence 1 n-tab-stops)))
    (unless (zerop (% max-col width))
      (setcdr (last tab-stop-list)
              (list max-col)))))

(defun my-prog-mode-tab-stuff ()
  (interactive)
  (setq indent-tabs-mode nil
        tab-stop-list (number-sequence 2 120 2))
  (set-tab-stop-width 2)
  (infer-indentation-style)
  (whitespace-mode))

(add-hook 'prog-mode-hook 'my-prog-mode-tab-stuff)

#+END_SRC

**** TODO flycheck?
**** TODO autoindent
- detect indentation settings from file, editor config or language

*** TODO Helm

#+BEGIN_SRC emacs-lisp

  (use-package helm
    :ensure t
    :commands (helm-mini helm-buffers-list)
    :bind (("M-x" . helm-M-x))
    :init (progn
            (require 'helm-config)
            (helm-mode)))

  (use-package helm-projectile
    :ensure t
    :bind (("C-c p h" . helm-projectile)
           ("C-c p p" . helm-projectile-switch-project)))

#+END_SRC

*** projectile

project based navigation, etc.

#+BEGIN_SRC emacs-lisp

  (use-package projectile
    :ensure t
    :diminish projectile-mode
    :init
    (setq projectile-enable-caching t
          projectile-cache-file "~/.emacs.d/projectile.cache"
          projectile-known-projects-file "~/.emacs.d/projectile-bookmarks.eld")
    :config
    (projectile-global-mode))

#+END_SRC

**** TODO projectile ag/grep
**** TODO workspaces?
**** TODO notes file?
**** TODO shells, etc.?

*** orgmode

#+BEGIN_SRC emacs-lisp

  (use-package org
    :ensure t
    :bind
      (("C-c oc" . org-capture)
       ("C-c oa" . org-agenda)
       ("C-c ol" . org-store-link))
    :config
      (progn
        (setq
         ;; syntax highlight inside of blocks
         org-src-fontify-natively t

         ;; use indent mode, which hides multiple ***, and autoindents instead
         org-startup-indented t

         org-agenda-files (list my/org-inbox-file my/org-journal-file)
         
         org-capture-templates
         `(("c" "Thought" entry (file+headline ,my/org-inbox-file "Thoughts")
            "* %?\n")
           ("t" "Todo" entry (file+headline ,my/org-inbox-file "Todo")
            "* TODO %?\n%U\n")
           ("j" "Journal Entry" entry (file+datetree ,my/org-journal-file)
            "* %<%T> %?\n")
           ("s" "Settings Idea" entry (file+headline "~/.emacs.d/settings.org" "future plans")
            "* %?\n")))))

#+END_SRC

*** magit

Invoke magit with ~C-c gs~ everywhere. Most of this from Lee.

#+BEGIN_Src emacs-lisp

(setq magit-last-seen-setup-instructions "1.4.0")
(use-package magit
  :ensure t
  :bind (("C-c gs" . magit-status))
  :config
  (xx progn
    (defun magit-browse ()
      "Browse to the project's github URL, if available"
      (interactive)
      (let ((url (with-temp-buffer
                   (unless (zerop (call-process-shell-command
                                   "git remote -v" nil t))
                     (error "Failed: 'git remote -v'"))
                   (goto-char (point-min))
                   (when (re-search-forward
                          "github\\.com[:/]\\(.+?\\)\\.git" nil t)
                     (format "https://github.com/%s" (match-string 1))))))
        (unless url
          (error "Can't find repository URL"))
        (browse-url url)))

    (define-key magit-mode-map (kbd "C-c C-b") 'magit-browse)
    (define-key magit-status-mode-map (kbd "W") 'magit-toggle-whitespace)))

#+END_SRC

** programming languages

*** helm-dash

Allows browsing dash documentation sets in emacs.

#+BEGIN_SRC emacs-lisp

(use-package helm-dash
  :ensure t
  :bind (("C-c hd" . helm-dash)
         ("C-c hh" . helm-dash-at-point)))

#+END_SRC

*** rust
#+BEGIN_SRC emacs-lisp

  (use-package rust-mode
    :ensure t
    :mode "\\.rs\\'")

#+END_SRC

*** markdown
#+BEGIN_SRC emacs-lisp

  (use-package markdown-mode
    :ensure t
    :mode "\\.md\\'")

#+END_SRC

*** ruby/rails

#+BEGIN_SRC emacs-lisp

(use-package rvm
  :ensure t
  :init (rvm-use-default)
  :config 
    (progn 
      (add-hook 'enh-ruby-mode-hook (lambda () (rvm-activate-corresponding-ruby)))
      (defadvice inf-ruby-console-auto (before activate-rvm-for-robe activate)
        (rvm-activate-corresponding-ruby))))

(use-package enh-ruby-mode
  :ensure t
  :mode (("\\(Rake\\|Thor\\|Guard\\|Gem\\|Cap\\|Vagrant\\)file\\'" . enh-ruby-mode)
         ("\\.\\(rb\\|rabl\\|ru\\|builder\\|rake\\|thor\\|gemspec\\|jbuilder\\)\\'" . enh-ruby-mode))
  :config (progn
            (setq enh-ruby-deep-indent-paren nil
                  enh-ruby-hanging-deep-indent-level 2)))

(use-package robe
  :ensure t
  :init 
    (progn
      (add-hook 'enh-ruby-mode-hook 'robe-mode))
  :config 
    (xx progn))

(use-package bundler :ensure t :defer t)
#+END_SRC

*** TODO json/javascript
*** TODO HTML
*** TODO CSS/SCSS
- color #333 style colorstrings with the value

** future plans

- auto completion
  - semantic auto completion / language specific?
  - cedet semantic mode
- get org-mode insert bindings to leave evil in insert mode; by this I mean that when hitting C-Ret to add another node, evil should be in insert mode after
- maximum width before wrapping for org-mode and text buffers
- have a way to create a capture buffer in a new empty frame, so that I can capture from a global hot key
- tramp lets you access remote systems (you can define protocols generically) via special paths, lee uses it to edit server files, etc.

** packages to check out:
- cedet
- volatile-highlights
- gist
- alert (some way to get notify pop ups system wide)
- multiple cursors
- eyebrows
- fill-column-indicator
- prodigy
- idle-highlight-mode
- ox-reveal
- ox-gfm
- paredit
- paren-face
